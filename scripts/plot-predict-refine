#!/usr/bin/env python

#
# Visualise behaviour of prediction refinement
#
# Copyright (c) 2015 Deutsches Elektronen-Synchrotron DESY,
#                    a research centre of the Helmholtz Association.
#
# Author:
#    2015 Thomas White <taw@physics.org>
#

import sys
import os
import re
import matplotlib.pyplot as plt


def show_frac(ratios, v):
    n = len([x for x in ratios if x < v])
    print "%4i (%.2f%%) new/old ratios are below %.2f" % (n, 100*float(n)/len(ratios), v)


f = open(sys.argv[1], 'r')

oldR = []
newR = []

prog1 = re.compile("^predict_refine/R\sold\s=\s([0-9\.\-]+)\snew\s=\s([0-9\.\-]+)\s")

while True:

    fline = f.readline()
    if not fline:
        break

    match = prog1.match(fline)
    if match:
        old = float(match.group(1))
        new = float(match.group(2))
        oldR.append(old)
        newR.append(new)

f.close()

mean_oldR = sum(oldR) / len(oldR)
mean_newR = sum(newR) / len(newR)
ratios = [new/old for new,old in zip(newR, oldR)];
print 'Mean profile radius before: %.2e, after: %.2e nm^-1' % (mean_oldR,mean_newR)
show_frac(ratios, 1.2)
show_frac(ratios, 1.1)
show_frac(ratios, 1.0)
show_frac(ratios, 0.9)
show_frac(ratios, 0.8)

#plt.plot(oldR, newR, 'rx')
plt.hist(ratios, 50)
#plt.axis([-2,2,-2,2])
plt.title('Profile radius before and after refinement')
plt.xlabel('x shift / mm')
plt.ylabel('y shift / mm')
plt.grid(True)
plt.show()

