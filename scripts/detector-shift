#!/usr/bin/env python

#
# Determine mean detector shift based on prediction refinement results
#
# Copyright (c) 2015 Deutsches Elektronen-Synchrotron DESY,
#                    a research centre of the Helmholtz Association.
#
# Author:
#    2015 Thomas White <taw@physics.org>
#

import sys
import os
import re

f = open(sys.argv[1], 'r')
if len(sys.argv) > 2:
    geom = sys.argv[2]
    have_geom = 1
else:
    have_geom = 0

# Determine the mean shifts
total_x = 0
total_y = 0
total_z = 0
n_xy = 0
n_z = 0

prog1 = re.compile("^predict_refine/det_shift\sx\s=\s([0-9\.\-]+)\sy\s=\s([0-9\.\-]+)\smm$")
prog2 = re.compile("^predict_refine/clen_shift\s=\s([0-9\.\-]+)\smm$")

while True:

    fline = f.readline()
    if not fline:
        break

    match = prog1.match(fline)
    if match:
        xshift = float(match.group(1))
        yshift = float(match.group(2))
        total_x += xshift
        total_y += yshift
        n_xy += 1

    match = prog2.match(fline)
    if match:
        zshift = float(match.group(1))
        total_z += xshift
        n_z += 1

if n_xy != n_z:
    print 'Warning: number of xy shifts not equal to number of z shifts'

mean_x = total_x / n_xy
mean_y = total_y / n_xy
mean_z = total_z / n_z

print 'Mean shifts: dx = %.2f mm,  dy = %.2f mm;  dz = %.2f mm' % (mean_x,mean_y,mean_z)
f.close()

if not have_geom:
    exit(0)

# Apply shifts to geometry
out = os.path.splitext(geom)[0]+'-predrefine.geom'
print 'Applying corrections to %s, output filename %s' % (geom,out)
g = open(geom, 'r')
h = open(out, 'w')

prog1 = re.compile("^\s*res\s+=\s+([0-9\.]+)\s")
prog2 = re.compile("^\s*(.*)\/res\s+=\s+([0-9\.]+)\s")
prog3 = re.compile("^\s*(.*)\/corner_x\s+=\s+([0-9\.]+)\s")
prog4 = re.compile("^\s*(.*)\/corner_y\s+=\s+([0-9\.]+)\s")
default_res = 0
while True:

    fline = g.readline()
    if not fline:
        break

    match = prog1.match(fline)
    if match:
        default_res = float(match.group(1))
        print 'default res %f' % (default_res)
	h.write(fline)
	continue

    match = prog2.match(fline)
    if match:
        panel = match.group(1)
	panel_res = float(match.group(2))
        print 'panel res %s / %f' % (panel, panel_res)
	h.write(fline)
	continue

    match = prog3.match(fline)
    if match:
        panel = match.group(1)
	panel_cnx = float(match.group(2))
	res = default_res     # FIXME!
	h.write('%s/corner_x = %f\n' % (panel,panel_cnx+(mean_x*res*1e-3)))
	continue

    match = prog4.match(fline)
    if match:
        panel = match.group(1)
	panel_cny = float(match.group(2))
	res = default_res     # FIXME!
	h.write('%s/corner_y = %f\n' % (panel,panel_cny+(mean_y*res*1e-3)))
	continue

    h.write(fline)

g.close()
h.close()
